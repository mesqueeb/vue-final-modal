{"version":3,"file":"VueFinalModal.esm.js","sources":["../lib/utils/focusTrap.js","../lib/utils/dragResize.js","../lib/utils/bodyScrollLock.js","../lib/VueFinalModal.vue","../lib/PluginCore.js","../lib/Plugin.js"],"sourcesContent":["// stolen from vue-js-modal\n\nconst FOCUSABLE_ELEMENTS_QUERY =\n  'button:not([disabled]), ' +\n  'select:not([disabled]), ' +\n  'a[href]:not([disabled]), ' +\n  'area[href]:not([disabled]), ' +\n  '[contentEditable=\"\"]:not([disabled]), ' +\n  '[contentEditable=\"true\"]:not([disabled]), ' +\n  '[contentEditable=\"TRUE\"]:not([disabled]), ' +\n  'textarea:not([disabled]), ' +\n  'iframe:not([disabled]), ' +\n  'input:not([disabled]), ' +\n  'summary:not([disabled]), ' +\n  '[tabindex]:not([tabindex=\"-1\"])'\n\nconst isTabPressed = event => {\n  return event.key === 'Tab' || event.keyCode === 9\n}\n\nconst querySelectorAll = (element, selector) => {\n  return [...(element.querySelectorAll(selector) || [])]\n}\n\nconst queryFocusableElements = element => {\n  return querySelectorAll(element, FOCUSABLE_ELEMENTS_QUERY)\n}\n\nconst isFocused = element => {\n  return element == document.activeElement\n}\n\nconst isNothingFocused = () => {\n  return !document.activeElement\n}\n\nclass FocusTrap {\n  constructor() {\n    this.root = null\n    this.elements = []\n\n    this.onKeyDown = this.onKeyDown.bind(this)\n    this.enable = this.enable.bind(this)\n    this.disable = this.disable.bind(this)\n    this.firstElement = this.firstElement.bind(this)\n    this.lastElement = this.lastElement.bind(this)\n  }\n\n  lastElement() {\n    return this.elements[this.elements.length - 1] || null\n  }\n\n  firstElement() {\n    return this.elements[0] || null\n  }\n\n  onKeyDown(event) {\n    if (!isTabPressed(event)) {\n      return\n    }\n\n    // SHIFT + TAB\n    if (event.shiftKey) {\n      if (isFocused(this.firstElement())) {\n        this.lastElement().focus()\n        event.preventDefault()\n      }\n      return\n    }\n\n    // TAB\n    if (isNothingFocused() || isFocused(this.lastElement())) {\n      this.firstElement().focus()\n      event.preventDefault()\n      return\n    }\n  }\n\n  enabled() {\n    return !!this.root\n  }\n\n  enable(root) {\n    if (!root) {\n      return\n    }\n\n    this.root = root\n    this.elements = queryFocusableElements(this.root)\n\n    this.root.addEventListener('keydown', this.onKeyDown)\n  }\n\n  disable() {\n    this.root.removeEventListener('keydown', this.onKeyDown)\n    this.root = null\n  }\n}\n\nexport default FocusTrap\n","export const setStyle = (el, key, value) => {\n  const cacheStyle = el.style[key]\n  el.style[key] = value\n  return () => {\n    el.style[key] = cacheStyle\n  }\n}\n\nexport const getPosition = e => {\n  const { clientX: x, clientY: y } = e.targetTouches ? e.targetTouches[0] : e\n  return { x, y }\n}\n\nexport const capitalize = s => {\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\nexport const clamp = (min, num, max) => {\n  if (typeof min !== 'number') {\n    min = Math.min(num, max) || num\n  }\n  if (typeof max !== 'number') {\n    max = Math.max(num, min)\n  }\n  return Math.min(Math.max(num, min), max)\n}\n\nexport const trimPx = distance => {\n  return (distance && Number(distance.replace(/px$/, ''))) || 0\n}\n\nexport const validDragElement = (e, el, dragSelector) => {\n  if (dragSelector === '') return true\n  const list = [...el.querySelectorAll(dragSelector)]\n  return list.includes(e.target)\n}\n\nconst pointerType = {\n  down: {\n    pc: 'mousedown',\n    m: 'touchstart'\n  },\n  move: {\n    pc: 'mousemove',\n    m: 'touchmove'\n  },\n  up: {\n    pc: 'mouseup',\n    m: 'touchend'\n  }\n}\nexport const addListener = (type, el, callback) => {\n  el && el.addEventListener(pointerType[type].pc, callback)\n  el && el.addEventListener(pointerType[type].m, callback, { passive: false })\n}\nexport const removeListener = (type, el, callback) => {\n  el && el.removeEventListener(pointerType[type].pc, callback)\n  el && el.removeEventListener(pointerType[type].m, callback)\n}\n","// stolen from body-scroll-lock\n\n// Older browsers don't support event options, feature detect it.\nlet hasPassiveEvents = false\nif (typeof window !== 'undefined') {\n  const passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true\n      return undefined\n    }\n  }\n  window.addEventListener('testPassive', null, passiveTestOptions)\n  window.removeEventListener('testPassive', null, passiveTestOptions)\n}\n\nconst isIosDevice =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.platform &&\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\n    (window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1))\n\nlet locks = []\nlet documentListenerAdded = false\nlet clientY = 0\nlet initialClientY = -1\nlet previousBodyOverflowSetting\nlet previousBodyPaddingRight\n\nconst hasScrollbar = el => {\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false\n\n  const style = window.getComputedStyle(el)\n  return ['auto', 'scroll'].includes(style.overflowY) && el.scrollHeight > el.clientHeight\n}\n\nconst shouldScroll = (el, delta) => {\n  if (el.scrollTop === 0 && delta < 0) return false\n  if (el.scrollTop + el.clientHeight + delta >= el.scrollHeight && delta > 0) return false\n  return true\n}\n\nconst composedPath = el => {\n  const path = []\n  while (el) {\n    path.push(el)\n    if (el.classList.contains('vfm')) return path\n    el = el.parentElement\n  }\n  return path\n}\n\nconst hasAnyScrollableEl = (el, delta) => {\n  let hasAnyScrollableEl = false\n  const path = composedPath(el)\n  path.forEach(el => {\n    if (hasScrollbar(el) && shouldScroll(el, delta)) {\n      hasAnyScrollableEl = true\n    }\n  })\n  return hasAnyScrollableEl\n}\n\n// returns true if `el` should be allowed to receive touchmove events.\nconst allowTouchMove = el => locks.some(() => hasAnyScrollableEl(el, -clientY))\n\nconst preventDefault = rawEvent => {\n  const e = rawEvent || window.event\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true\n  }\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true\n\n  if (e.preventDefault) e.preventDefault()\n\n  return false\n}\n\nconst setOverflowHidden = options => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true\n    const scrollBarGap = window.innerWidth - document.documentElement.clientWidth\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10)\n      previousBodyPaddingRight = document.body.style.paddingRight\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`\n    }\n  }\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow\n    document.body.style.overflow = 'hidden'\n  }\n}\n\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined\n  }\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nconst isTargetElementTotallyScrolled = targetElement =>\n  targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false\n\nconst handleScroll = (event, targetElement) => {\n  clientY = event.targetTouches[0].clientY - initialClientY\n\n  if (allowTouchMove(event.target)) {\n    return false\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event)\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event)\n  }\n\n  event.stopPropagation()\n  return true\n}\n\nexport const disableBodyScroll = (targetElement, options) => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(lock => lock.targetElement === targetElement)) {\n    return\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {}\n  }\n\n  locks = [...locks, lock]\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY\n      }\n    }\n    targetElement.ontouchmove = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement)\n      }\n    }\n\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = true\n    }\n  } else {\n    setOverflowHidden(options)\n  }\n}\n\nexport const enableBodyScroll = targetElement => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null\n    targetElement.ontouchmove = null\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = false\n    }\n  } else if (!locks.length) {\n    restoreOverflowSetting()\n  }\n}\n","<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      ref=\"vfmOverlayTransition\"\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-show=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      ref=\"vfmTransition\"\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @mouseup.self=\"onMouseupContainer\"\n        @mousedown.self=\"onMousedown\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"bindContentStyle\"\n          @mousedown=\"onMousedown(null)\"\n        >\n          <slot :params=\"params\" :close=\"() => $emit('input', false)\" />\n          <div\n            v-if=\"visibility.resize && visibility.modal\"\n            ref=\"vfmResize\"\n            class=\"vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none\"\n          >\n            <div\n              v-for=\"direction in resizeDirections\"\n              :key=\"direction\"\n              :direction=\"direction\"\n              :class=\"`vfm--resize-${direction}`\"\n              class=\"vfm--absolute vfm--prevent-auto\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport FocusTrap from './utils/focusTrap.js'\nimport {\n  setStyle,\n  getPosition,\n  capitalize,\n  clamp,\n  trimPx,\n  validDragElement,\n  addListener,\n  removeListener\n} from './utils/dragResize.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nfunction validateAttachTarget(val) {\n  const type = typeof val\n\n  if (type === 'boolean' || type === 'string') return true\n\n  return val.nodeType === Node.ELEMENT_NODE\n}\n\nconst CLASS_PROP = {\n  type: [String, Object, Array],\n  default: ''\n}\n\nconst STYLE_PROP = {\n  type: [Object, Array],\n  default: () => ({})\n}\n\nconst resizeCursor = {\n  t: 'ns-resize',\n  tr: 'nesw-resize',\n  r: 'ew-resize',\n  br: 'nwse-resize',\n  b: 'ns-resize',\n  bl: 'nesw-resize',\n  l: 'ew-resize',\n  tl: 'nwse-resize'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    value: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: CLASS_PROP,\n    overlayClass: CLASS_PROP,\n    contentClass: CLASS_PROP,\n    styles: STYLE_PROP,\n    overlayStyle: STYLE_PROP,\n    contentStyle: STYLE_PROP,\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: { type: null, default: false, validator: validateAttachTarget },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false },\n    fitParent: { type: Boolean, default: true },\n    drag: { type: Boolean, default: false },\n    dragSelector: { type: String, default: '' },\n    keepChangedStyle: { type: Boolean, default: false },\n    resize: {\n      type: Boolean,\n      default: false\n    },\n    resizeDirections: {\n      type: Array,\n      default: () => ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],\n      validator: val =>\n        ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'].filter(value => val.indexOf(value) !== -1).length === val.length\n    },\n    minWidth: { type: Number, default: 0 },\n    minHeight: { type: Number, default: 0 },\n    maxWidth: { type: Number, default: Infinity },\n    maxHeight: { type: Number, default: Infinity }\n  },\n  data: () => ({\n    modalStackIndex: null,\n    visible: false,\n    visibility: {\n      modal: false,\n      overlay: false,\n      resize: false\n    },\n    overlayTransitionState: null,\n    modalTransitionState: null,\n    stopEvent: false,\n    params: {},\n    dragResizeStyle: {},\n    resolveToggle: noop,\n    rejectToggle: noop,\n    state: null,\n    lastMousedownEl: null\n  }),\n  computed: {\n    isComponentReadyToBeDestroyed() {\n      return (\n        (this.hideOverlay || this.overlayTransitionState === TransitionState.Leave) &&\n        this.modalTransitionState === TransitionState.Leave\n      )\n    },\n    calculateZIndex() {\n      if (this.zIndex === false) {\n        if (this.zIndexAuto) {\n          return +this.zIndexBase + 2 * (this.modalStackIndex || 0)\n        } else {\n          return false\n        }\n      } else {\n        return this.zIndex\n      }\n    },\n    bindStyle() {\n      return {\n        ...(this.calculateZIndex !== false && { zIndex: this.calculateZIndex })\n      }\n    },\n    bindContentStyle() {\n      let style = [this.dragResizeStyle]\n      Array.isArray(this.contentStyle) ? style.push(...this.contentStyle) : style.push(this.contentStyle)\n      return style\n    },\n    computedTransition() {\n      if (typeof this.transition === 'string') return { name: this.transition }\n      return { ...this.transition }\n    },\n    computedOverlayTransition() {\n      if (typeof this.overlayTransition === 'string') return { name: this.overlayTransition }\n      return { ...this.overlayTransition }\n    }\n  },\n  watch: {\n    value(value) {\n      if (this.stopEvent) {\n        this.stopEvent = false\n        return\n      }\n      this.mounted()\n      if (!value) {\n        if (this.emitEvent('before-close', true)) {\n          this.rejectToggle('hide')\n          return\n        }\n        this.close()\n      }\n    },\n    lockScroll: 'handleLockScroll',\n    hideOverlay(value) {\n      if (this.value && !value) {\n        this.visibility.overlay = true\n      }\n    },\n    attach: 'mounted',\n    isComponentReadyToBeDestroyed(isReady) {\n      if (isReady) {\n        this.visible = false\n      }\n    },\n    drag(value) {\n      if (this.visible) {\n        value ? this.addDragDown() : this.removeDragDown()\n      }\n    },\n    resize(value) {\n      if (this.visible) {\n        value ? this.addResizeDown() : this.removeResizeDown()\n      }\n    },\n    keepChangedStyle(value) {\n      if (!value) {\n        this.dragResizeStyle = {}\n      }\n    }\n  },\n  created() {\n    this.api.modals.push(this)\n  },\n  mounted() {\n    this.$focusTrap = new FocusTrap()\n    this.mounted()\n  },\n  beforeDestroy() {\n    this.close()\n    this.lockScroll && this.$refs.vfmContainer && enableBodyScroll(this.$refs.vfmContainer)\n    this?.$el?.remove()\n\n    let index = this.api.modals.findIndex(vm => vm === this)\n    this.api.modals.splice(index, 1)\n  },\n  methods: {\n    mounted() {\n      if (this.value) {\n        if (this.emitEvent('before-open', false)) {\n          this.rejectToggle('show')\n          return\n        }\n        let target = this.getAttachElement()\n        if (target || this.attach === false) {\n          this.attach !== false && target.appendChild(this.$el)\n\n          let index = this.api.openedModals.findIndex(vm => vm === this)\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            this.api.openedModals.splice(index, 1)\n          }\n          this.api.openedModals.push(this)\n\n          this.modalStackIndex = this.api.openedModals.length - 1\n\n          this.handleLockScroll()\n          this.api.openedModals\n            .filter(vm => vm !== this)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex = index\n                vm.visibility.overlay = false\n              }\n            })\n\n          this.visible = true\n          this.$nextTick(() => {\n            this.startTransitionEnter()\n          })\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(this.attach))\n        }\n      }\n    },\n    close() {\n      let index = this.api.openedModals.findIndex(vm => vm === this)\n      if (index !== -1) {\n        // remove this in modalStack\n        this.api.openedModals.splice(index, 1)\n      }\n      if (this.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = this.api.openedModals[this.api.openedModals.length - 1]\n        if ($_vm.focusRetain || $_vm.focusTrap) {\n          $_vm.$refs.vfmContainer.focus()\n        }\n        !$_vm.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      this.drag && this.removeDragDown()\n      this.resize && this.removeResizeDown()\n      this.state = null\n\n      this.startTransitionLeave()\n    },\n    startTransitionEnter() {\n      this.visibility.overlay = true\n      this.visibility.modal = true\n    },\n    startTransitionLeave() {\n      this.visibility.overlay = false\n      this.visibility.modal = false\n    },\n    handleLockScroll() {\n      if (this.value) {\n        this.$nextTick(() => {\n          if (this.lockScroll) {\n            disableBodyScroll(this.$refs.vfmContainer, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(this.$refs.vfmContainer)\n          }\n        })\n      }\n    },\n    getAttachElement() {\n      let target\n      if (this.attach === false) {\n        target = false\n      } else if (typeof this.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(this.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = this.attach\n      }\n      return target\n    },\n    beforeOverlayEnter() {\n      this.overlayTransitionState = TransitionState.Entering\n    },\n    afterOverlayEnter() {\n      this.overlayTransitionState = TransitionState.Enter\n    },\n    beforeOverlayLeave() {\n      this.overlayTransitionState = TransitionState.Leaving\n    },\n    afterOverlayLeave() {\n      this.overlayTransitionState = TransitionState.Leave\n    },\n    beforeModalEnter() {\n      this.modalTransitionState = TransitionState.Entering\n    },\n    afterModalEnter() {\n      this.modalTransitionState = TransitionState.Enter\n      if (this.focusRetain || this.focusTrap) {\n        this.$refs.vfmContainer.focus()\n      }\n      this.focusTrap && this.$focusTrap.enable(this.$refs.vfmContainer)\n      this.drag && this.addDragDown()\n      this.resize && this.addResizeDown()\n\n      this.$emit('opened', this.createModalEvent({ type: 'opened' }))\n      this.resolveToggle('show')\n    },\n    beforeModalLeave() {\n      this.modalTransitionState = TransitionState.Leaving\n\n      if (this.$focusTrap.enabled()) {\n        this.$focusTrap.disable()\n      }\n    },\n    afterModalLeave() {\n      this.modalTransitionState = TransitionState.Leave\n      this.modalStackIndex = null\n      this.lockScroll && enableBodyScroll(this.$refs.vfmContainer)\n      if (!this.keepChangedStyle) {\n        this.dragResizeStyle = {}\n      }\n\n      let stopEvent = false\n      const event = this.createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      this.$emit('closed', event)\n      this.resolveToggle('hide')\n      if (stopEvent) return\n      this.params = {}\n    },\n    onMousedown(e) {\n      this.lastMousedownEl = e?.target\n    },\n    onMouseupContainer() {\n      // skip when the lastMousedownEl didn't equal $refs.vfmContainer\n      if (this.lastMousedownEl !== this.$refs.vfmContainer) return\n      // skip when state equal 'resize:move'\n      if (this.state === 'resize:move') return\n      this.$emit('click-outside', this.createModalEvent({ type: 'click-outside' }))\n      this.clickToClose && this.$emit('input', false)\n    },\n    onEsc() {\n      if (this.visible && this.escToClose) {\n        this.$emit('input', false)\n      }\n    },\n    createModalEvent(eventProps = {}) {\n      return {\n        ref: this,\n        ...eventProps\n      }\n    },\n    emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = this.createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      this.$emit(eventType, event)\n      if (stopEvent) {\n        this.stopEvent = true\n        this.$emit('input', value)\n        return true\n      }\n      return false\n    },\n    emitState(e, state, action) {\n      this.state = `${state}:${action}`\n      this.$emit(this.state, e)\n    },\n    toggle(show, params) {\n      return new Promise((resolve, reject) => {\n        this.resolveToggle = res => {\n          resolve(res)\n          this.resolveToggle = noop\n        }\n        this.rejectToggle = err => {\n          reject(err)\n          this.rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !this.value\n        if (value && arguments.length === 2) {\n          this.params = params\n        }\n        this.$emit('input', value)\n      })\n    },\n    pointerDown(e) {\n      e.stopPropagation()\n      const STATE_RESIZE = 'resize'\n      const STATE_DRAG = 'drag'\n      const { vfmContainer, vfmContent } = this.$refs\n      const direction = e.target.getAttribute('direction')\n      let state\n      if (direction) {\n        state = STATE_RESIZE\n      } else if (validDragElement(e, vfmContent, this.dragSelector)) {\n        state = STATE_DRAG\n      } else {\n        return\n      }\n      this.emitState(e, state, 'start')\n      const down = getPosition(e)\n      const rectContainer = vfmContainer.getBoundingClientRect()\n      const rectContent = vfmContent.getBoundingClientRect()\n      const isAbsolute = window.getComputedStyle(vfmContent).position === 'absolute'\n      const position = {\n        top: trimPx(this.dragResizeStyle.top),\n        left: trimPx(this.dragResizeStyle.left)\n      }\n      const limit = (() => {\n        if (this.fitParent) {\n          const limit = {\n            absolute() {\n              return {\n                minTop: 0,\n                minLeft: 0,\n                maxTop: rectContainer.height - rectContent.height,\n                maxLeft: rectContainer.width - rectContent.width\n              }\n            },\n            relative() {\n              return {\n                minTop: position.top + rectContainer.top - rectContent.top,\n                minLeft: position.left + rectContainer.left - rectContent.left,\n                maxTop: position.top + rectContainer.bottom - rectContent.bottom,\n                maxLeft: position.left + rectContainer.right - rectContent.right\n              }\n            }\n          }\n          return isAbsolute ? limit.absolute() : limit.relative()\n        } else {\n          return {}\n        }\n      })()\n      const resetBodyCursor = state === STATE_RESIZE && setStyle(document.body, 'cursor', resizeCursor[direction])\n\n      const moving = e => {\n        // onPointerMove\n        e.stopPropagation()\n        this.emitState(e, state, 'move')\n        const move = getPosition(e)\n        let offset = {\n          x: move.x - down.x,\n          y: move.y - down.y\n        }\n        if (state === STATE_RESIZE) {\n          offset = this.getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute)\n        }\n\n        let top\n        let left\n        if (isAbsolute) {\n          top = rectContent.top - rectContainer.top + offset.y\n          left = rectContent.left - rectContainer.left + offset.x\n        } else {\n          top = position.top + offset.y\n          left = position.left + offset.x\n        }\n        if (state === STATE_DRAG && this.fitParent) {\n          top = clamp(limit.minTop, top, limit.maxTop)\n          left = clamp(limit.minLeft, left, limit.maxLeft)\n        }\n        const style = {\n          position: 'relative',\n          top: top + 'px',\n          left: left + 'px',\n          margin: 'unset',\n          touchAction: 'none',\n          ...(isAbsolute && {\n            position: 'absolute',\n            transform: 'unset',\n            width: rectContent.width + 'px',\n            height: rectContent.height + 'px'\n          }),\n          ...(offset.width && { width: offset.width + 'px' }),\n          ...(offset.height && { height: offset.height + 'px' })\n        }\n\n        this.dragResizeStyle = {\n          ...this.dragResizeStyle,\n          ...style\n        }\n      }\n      const end = e => {\n        // onPointerUp\n        e.stopPropagation()\n        if (state === STATE_RESIZE) {\n          resetBodyCursor && resetBodyCursor()\n        }\n        // Excute onClickContainer before trigger emitState\n        setTimeout(() => {\n          this.emitState(e, state, 'end')\n        })\n        removeListener('move', document, moving)\n        removeListener('up', document, end)\n      }\n      addListener('move', document, moving)\n      addListener('up', document, end)\n    },\n    addDragDown() {\n      addListener('down', this.$refs.vfmContent, this.pointerDown)\n      this.dragResizeStyle.touchAction = 'none'\n    },\n    removeDragDown() {\n      removeListener('down', this.$refs.vfmContent, this.pointerDown)\n    },\n    addResizeDown() {\n      this.visibility.resize = true\n      this.$nextTick(() => {\n        addListener('down', this.$refs.vfmResize, this.pointerDown)\n      })\n    },\n    removeResizeDown() {\n      removeListener('down', this.$refs.vfmResize, this.pointerDown)\n      this.visibility.resize = false\n    },\n    getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute) {\n      const setOffset = dir => {\n        let offsetAxis = offset[dir.axis]\n        offsetAxis = this.fitParent ? clamp(dir.min, offsetAxis, dir.max) : offsetAxis\n        let edge = clamp(dir.minEdge, dir.getEdge(offsetAxis), dir.maxEdge)\n        offsetAxis = dir.getOffsetAxis(edge, isAbsolute)\n        return {\n          [dir.edgeName]: edge,\n          [dir.axis]: offsetAxis\n        }\n      }\n\n      const getDirectionInfo = (position, edgeName, axis, isPositive) => {\n        const rectContentEdge = rectContent[edgeName]\n        const positionOffset = rectContainer[position] - rectContent[position]\n        const EdgeName = capitalize(edgeName)\n        return {\n          axis,\n          edgeName,\n          min: isPositive ? positionOffset : -rectContentEdge,\n          max: isPositive ? rectContentEdge : positionOffset,\n          minEdge: this[`min${EdgeName}`],\n          maxEdge: this[`max${EdgeName}`],\n          getEdge: offsetAxis => rectContent[edgeName] - offsetAxis * (isPositive ? 1 : -1),\n          getOffsetAxis: (edge, isAbsolute) => {\n            const offsetAxis = rectContent[edgeName] - edge\n            if (isAbsolute) {\n              return isPositive ? offsetAxis : 0\n            } else {\n              return ((isPositive ? 1 : -1) * offsetAxis) / 2\n            }\n          }\n        }\n      }\n\n      const directions = {\n        t: ['top', 'height', 'y', true],\n        b: ['bottom', 'height', 'y', false],\n        l: ['left', 'width', 'x', true],\n        r: ['right', 'width', 'x', false]\n      }\n\n      let _offset = { x: 0, y: 0 }\n      direction.split('').forEach(dir => {\n        const directionInfo = getDirectionInfo(...directions[dir])\n        _offset = {\n          ..._offset,\n          ...setOffset(directionInfo)\n        }\n      })\n      return _offset\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter,\n.vfm-leave-to {\n  opacity: 0;\n}\n\n.vfm--touch-none {\n  touch-action: none;\n}\n.vfm--select-none {\n  user-select: none;\n}\n\n.vfm--resize-tr,\n.vfm--resize-br,\n.vfm--resize-bl,\n.vfm--resize-tl {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n\n.vfm--resize-t {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n</style>\n","import Vue from 'vue'\nimport VueFinalModal from './VueFinalModal.vue'\nimport ModalsContainer from './ModalsContainer.vue'\n\nexport function defineApi() {\n  let _modalComponent = null\n\n  return Vue.observable({\n    show(modal, ...args) {\n      switch (typeof modal) {\n        case 'string':\n          return this.toggle(modal, true, ...args)\n        case 'object': {\n          return Promise.allSettled([\n            new Promise((resolve, reject) => {\n              const defaultModal = {\n                value: true,\n                id: Symbol('dynamicModal'),\n                component: _modalComponent,\n                bind: {},\n                slots: {},\n                on: {},\n                params: args[0],\n                reject,\n                opened() {\n                  resolve('show')\n                }\n              }\n              this.dynamicModals.push(Object.assign(defaultModal, modal))\n            })\n          ])\n        }\n      }\n    },\n    hide(...names) {\n      return this.toggle(names, false)\n    },\n    hideAll() {\n      return this.hide(...this.openedModals.map(modal => modal.name))\n    },\n    toggle(name, ...args) {\n      const modals = Array.isArray(name) ? this.get(...name) : this.get(name)\n      return Promise.allSettled(modals.map(modal => modal.toggle(...args)))\n    },\n    get(...names) {\n      return this.modals.filter(modal => names.includes(modal.name))\n    },\n    dynamicModals: [],\n    openedModals: [],\n    modals: [],\n    _setDefaultModal(modalComponent) {\n      _modalComponent = modalComponent\n    }\n  })\n}\n\nfunction bindApi(component, api) {\n  const _component = { ...component, props: { ...component.props } }\n  Object.assign(_component.props, {\n    api: { type: Object, default: () => api }\n  })\n  return _component\n}\n\nexport function defineModal(api) {\n  const modalComponent = bindApi(VueFinalModal, api)\n  api._setDefaultModal(modalComponent)\n  return modalComponent\n}\n\nexport function defineContainer(api) {\n  return bindApi(ModalsContainer, api)\n}\n","import { defineApi, defineModal, defineContainer } from './PluginCore'\n\n/**\n * @description Ensure that `_vfm` is used when function `installPlugin` is executed for the first time\n */\nlet _count = 0\n\nconst _key = '$vfm'\nconst _componentName = 'VueFinalModal'\nconst _dynamicContainerName = 'ModalsContainer'\n\n/**\n * @description Support create multiple vfm instance\n */\nexport const defineVfm = () => {\n  let api = defineApi()\n  return {\n    [_key]: api,\n    [_componentName]: defineModal(api),\n    [_dynamicContainerName]: defineContainer(api)\n  }\n}\n\n/**\n * @description Create a vfm instance by default for directly support `import { $vfm, VueFinalModal, ModalsContainer } from 'vue-final-modal'`\n */\nconst _vfm = defineVfm()\nexport const { $vfm, VueFinalModal, ModalsContainer } = _vfm\n\n/**\n * @description Register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nconst installVfm = (Vue, options = {}) => {\n  const { $vfm, VueFinalModal, ModalsContainer } = _count === 0 ? _vfm : defineVfm()\n  _count += 1\n  const key = options.key || _key\n  const componentName = options.componentName || _componentName\n  const dynamicContainerName = options.dynamicContainerName || _dynamicContainerName\n  Vue.prototype[key] = $vfm\n  Vue.component(componentName, VueFinalModal)\n  Vue.component(dynamicContainerName, ModalsContainer)\n}\n\n/**\n * @description Vue plugin for register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nexport const vfmPlugin = pluginOptions => ({\n  install(Vue, options) {\n    const _options = Object.assign({}, pluginOptions, options)\n    installVfm(Vue, _options)\n  }\n})\n\nvfmPlugin.install = installVfm\n"],"names":["queryFocusableElements","element","selector","querySelectorAll","isFocused","document","activeElement","FocusTrap","root","elements","onKeyDown","this","bind","enable","disable","firstElement","lastElement","length","event","key","keyCode","isTabPressed","shiftKey","focus","preventDefault","addEventListener","removeEventListener","getPosition","e","targetTouches","x","clientX","y","clientY","clamp","min","num","max","Math","trimPx","distance","Number","replace","pointerType","down","pc","m","move","up","addListener","type","el","callback","passive","removeListener","hasPassiveEvents","window","passiveTestOptions","previousBodyOverflowSetting","previousBodyPaddingRight","isIosDevice","navigator","platform","test","maxTouchPoints","locks","documentListenerAdded","initialClientY","hasAnyScrollableEl","delta","path","push","classList","contains","parentElement","composedPath","forEach","nodeType","Node","ELEMENT_NODE","style","getComputedStyle","includes","overflowY","scrollHeight","clientHeight","hasScrollbar","scrollTop","shouldScroll","allowTouchMove","some","rawEvent","target","touches","disableBodyScroll","targetElement","options","lock","ontouchstart","ontouchmove","isTargetElementTotallyScrolled","stopPropagation","handleScroll","undefined","reserveScrollBarGap","scrollBarGap","innerWidth","documentElement","clientWidth","computedBodyPaddingRight","parseInt","body","getPropertyValue","paddingRight","overflow","setOverflowHidden","console","error","enableBodyScroll","filter","dragSelector","value","cacheStyle","s","charAt","toUpperCase","slice","bindApi","component","api","_component","props","Object","assign","_count","defineVfm","_modalComponent","Vue","observable","show","modal","args","toggle","Promise","allSettled","resolve","reject","defaultModal","id","Symbol","slots","on","params","opened","_this","dynamicModals","hide","names","hideAll","openedModals","map","name","modals","Array","isArray","get","_setDefaultModal","modalComponent","VueFinalModal","defineModal","ModalsContainer","defineContainer","_vfm","$vfm","installVfm","componentName","dynamicContainerName","prototype","vfmPlugin","pluginOptions","install","_options"],"mappings":"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"}